
;;
; nw
;;





;;
;  rq : hardcore computationally : shortest distance recomputed in each potential function for each other city !!!
to-report network:time-network [#startpoint #destination]
  report [ nw:weighted-distance-to #startpoint "weight"] of #destination
end





;;
; speed of links depends on time period
to-report current-speed
  let speed-date 0 let i 0
  foreach techno-break-years [
    if ticks <= ? [set speed-date item i network-speeds]
    set i i + 1
  ]
  report speed-date
end


;;
; link coloring according to period
;  (thematic periods)
to-report current-color
  let color-date 0 let i 0
  foreach techno-break-years [
    if ticks <= ? [set color-date item i network-colors]
    set i i + 1
  ]
  report color-date
end


;;
; Network growth
to network:grow-network
  if (Network-growth = "scenario")     [grow-net-scenario]
  if (Network-growth = "coevolution")  [grow-net-coevolution]
end




;;
; Network Growth Scenario
; HARDCORE !
; what sense does it make ? maybe if indics to compare network indicators ?
to grow-net-scenario
  
  if ticks = 1802 [ ask city 48 [ create-link-with city 58 [ actualisation-of-link ] ]]
  if ticks = 1805 [ ask link 58 38 [ actualisation-of-link ] ]
  if ticks = 1810 [ ask city 48 [ create-link-with city 91 [ actualisation-of-link ] ]]
  if ticks = 1812 [ ask city 48 [ create-link-with city 76 [ actualisation-of-link ] ]]
  if ticks = 1818 [ ask city 38 [ create-link-with city 6 [ actualisation-of-link ] ]]
  if ticks = 1820 [ ask link 58 8 [ actualisation-of-link ] ]
  if ticks = 1825 [ ask city 48 [ create-link-with city 65 [ actualisation-of-link ] ]]
  if ticks = 1830 [ ask city 48 [ create-link-with city 3 [ actualisation-of-link ] ]]
  if ticks = 1840 [ ask city 3 [ create-link-with city 61 [ actualisation-of-link ] ]]
  if ticks = 1846 [ ask city 61 [ create-link-with city 6 [ actualisation-of-link ] ]]
    
  if ticks = 1865 [ ask link 48 91 [ actualisation-of-link ] ]
  if ticks = 1870 [ ask city 91 [ create-link-with city 11 [ actualisation-of-link ] ]]
  if ticks = 1880 [ ask link 48 58 [ actualisation-of-link ] ]
  if ticks = 1889 [ ask link 6 61 [ actualisation-of-link ] ]
  if ticks = 1905 [ ask city 6 [ create-link-with city 3 [ actualisation-of-link ] ]]
  if ticks = 1912 [ ask city 46 [ create-link-with city 48 [ actualisation-of-link ] ]]
  
  if ticks = 1964 [ ask link 48 58 [ actualisation-of-link ] ]
  if ticks = 1969 [ ask link 48 91 [ actualisation-of-link ] ]
  if ticks = 1972 [ ask link 48 3 [ actualisation-of-link ] ]
  if ticks = 1912 [ ask city 3 [ create-link-with city 6 [ actualisation-of-link ] ]]
  
end






;; 
;  cache network indicators
to network:cache-nw-measures
  nw:set-context turtles links
  ask links [set bw-centrality 0]
  set nw-relative-speeds table:make set pairs-total-weight 0
  let clist to-list cities let i 0 let j 1
  repeat (length clist - 1) [
    let c1 item i clist
    set j i + 1
    repeat (length clist - i - 1) [
      let c2 item j clist let path [] let tpath [] ask c1 [set path nw:weighted-path-to c2 "weight"]
      let l 0 foreach path [ask ? [set l l + weight set bw-centrality bw-centrality + 1]]
      let deucl 0 ask c1 [set deucl distance c2]
      table:put nw-relative-speeds (list [who] of c1 [who] of c2) (deucl / l)
      set pairs-total-weight pairs-total-weight + [population] of c1 + [population] of c2
      set j j + 1
    ]
    set i i + 1
  ]
end







 


;******************************************************
; Lottery mecanisms for the random selection of cities
;******************************************************

to-report city-1pick
  ; The random election is made accroding to the population of the cities
  let totpopI random-float sumlottery
  let cityI nobody
  ask cities
  [if cityI = nobody
    [ifelse (population ^ network-gamma) > totpopI
      [set cityI self]
      [set totpopI totpopI - (population ^ network-gamma)]
    ]
  ]
 report cityI 
end



;;
; Preferential attachment growth mechanism ? (depending on interaction potential ?)
to-report lottery-potentiel [#1pick]
  ; The random election is made accroding to the interaction potentiel of each cities with the first city picked
  calcul-potentiels #1pick
  let pool-cities cities with [who != [who] of #1pick]
  
  let totpotentiel random-float sum [potentiel-interaction ^ network-gamma] of pool-cities
  let city-picked nobody
  ask pool-cities
  [
   if city-picked = nobody
   [
     ifelse (potentiel-interaction ^ network-gamma) > totpotentiel
     [set city-picked self]
     [set totpotentiel totpotentiel - (potentiel-interaction ^ network-gamma) ] 
   ]
  ]
  report city-picked
  
end




to update-networks-info [#city]
  let citiesPop reverse sort [population] of cities
  let myRank (position ([population] of #city) citiesPop) + 1
  
  ifelse (ticks <= 70)[
   ask #city [if (item 0 network1 = "") [ set network1 (list ticks myRank) ]]
    ][
    ifelse (ticks <= 150) [
      ask #city [if (item 0 network2 = "") [ set network2 (list ticks myRank)]]
      ][
      ask #city [if (item 0 network3 = "") [ set network3 (list ticks myRank)]]
      ]
    ]
end
  
  
  
 
 
; to compute-min-time-network
;   
;   ask cities [set min-time-neighbor city-min-time-neighbor]
;   set min-time-network min [min-time-neighbor] of cities
;   print min-time-network
;   
; end
 










;;
; Actualisation of link parameters
to actualisation-of-link
    set speed current-speed
    set weight (link-length / speed)
    set color current-color 
    set thickness 0.5
end





;;
; synthetic initial network
to local-shortcuts
  
  repeat synthetic-shortcut-number [
    ; draw randomly one city prop to pop conditionnally to degree
    let potential-cities (cities with [count my-links < synthetic-city-max-degree])
    let ptot sum [population] of potential-cities let r random-float 1 let s 0 let found? false
    ask potential-cities [
      set s s + (population / ptot)
      if s > r and not found? [
        set found? true let potential-dest (((other cities) in-radius synthetic-shortcut-radius) with [count my-links < synthetic-city-max-degree and not link-neighbor? myself])
        if count potential-dest > 0 [create-link-with one-of potential-dest]
      ] 
    ]
  ]
  
end




  
