
;;;;
;; cities
;;;;





to cities:grow-cities
  
  if (city-growth-model = "Gibrat")       [grow-gibrat]
  if (city-growth-model = "coevolution")  [grow-coevolution]
  
end



;;
; gibrat

;;
;
to grow-gibrat
  ask cities [
    let previous-pop population
    set population max list 0 ((previous-pop * (1 + gibrat-growthrate)))
    if population < 1 [die]
  ]
end



;;
; Gibrat growth rate
; not necessary ? -> may be useful in case of various implementation (noisy Gibrat, etc)
to-report gibrat-growthrate
  let rand-nb 0
  set rand-nb random-normal gibrat-mean gibrat-std
  report rand-nb
end



;;
;
to cities:compute-tempor-pop
  ask cities [ 
    set N-city-pot-int ((gravity-decay ^ gravity-gamma) * ((count cities) / system-pot-int) * city-pot-int)
    set  tmp-pop (population * (1 + N-city-pot-int))
  ]
end 
  
  
  
  
;;
; time to closest neighbor in network
to-report city-min-time-neighbor
     let l-MT []
     ask other cities [
        let MT network:time-network self myself
        set l-MT lput MT l-MT
     ]
     report min l-mt
end

  
;;
;   
to cities:compute-city-pot-int
   ask cities [
     let listpotF []
     ask other cities [
       let potF (( [population] of self) / ((network:time-network self myself + 1) ) ^ gravity-gamma)
       set listpotF lput potF listpotF
     ]   
     set city-pot-int sum listpotF
   ]
   
   ; update global pot int
   set system-pot-int (sum [city-pot-int] of cities)
   
end  
  
  


;;
; Compute cities accessibility ; updates distance matrix
;    Shimbel accessibility = mean network travel time
;    A_i = \sum_j t_{nw}(i,j)
to cities:calculate-accessibility
   ask cities [
     let listpcc []
     ask other cities [
       let tpspcc network:time-network self myself
       set listpcc lput tpspcc listpcc
       matrix:set distance-matrix ([index] of myself) index tpspcc
     ]
     set accessibility sum listpcc
   ]
end
 


;;
; new city
to new-city
  set shape "circle"
end  
 
 
;;
; city level indicators

; population
to-report city-population
  report population
end

; closeness
to-report city-closeness-centrality
   let d matrix:get-row distance-matrix index
   let s 0 let i 0 foreach d [if i != index [set s s + 1 / ?] set i i + 1]
   report s / ((length d) - 1)
end

; accessibility
to-report city-accessibility
  let d matrix:get-row distance-matrix index
  let pops replace-item index (matrix:get-column populations (ticks - initial-time-step)) 0
  ;report sum list-times-element-wise pops (map [exp (- ? / gravity-decay)] d)
  report sum list-times-element-wise pops (map [1 / ((? + 1) ^ gravity-gamma)] d)
end
 
 
 
 
to cities:update-population-matrix
  ask cities [
     matrix:set populations index (ticks + 1) population
  ]
end
 
 
 
 

